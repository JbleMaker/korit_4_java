### 배열, method overloading, 상속(inhritance), super, final, overide
#### 메서드 재정의 -> setter / getter

## 배열을 기준으로 1, 2차로 나눠서 선언방법 / 초기화 방법
## element 추출방식, 배열 전체 String 형태로 출력하는 방법
### Arrays.sort() -> overloading 개념과 합쳐져서 어떻게 사용되는지

## 상속
### override vs. overloading
### super 키워드 정리 

## int getter의 경우 출력문을 작성하고 싶으면 .main단계에서 어떤 꼼수를 쓸 수 있는지

1. 오버로딩 overloading
   - 메소드의 이름이 같고, 매개변수의 개수나 타입이 달라야 한다.
   - 주의 : '리턴 값만' 다른 것은 오버로딩을 할 수 없다.   
   - 오버로딩은 매개변수의 차이로만 구현.   
   ========================   
   - 장점
     1. 같은 기능을 하는 메소드를 하나의 이름으로 사용.
     2. 메소드의 이름을 절약할 수 있다.

2. 오버라이드 override
   - 부모 클래스로부터 상속 받은 메소드를 자식 클래스에서 재정의
   - 상속받은 메서드를 그대로 사용도 가능.
   - 자식클래스에서는 오버라이딩하고자 하는 메소드의 이름, 매개변수, 리턴값이 모두 같아야 한다.

   1. 오버라이드에서 접근제어자 설정 규칙
      - 자식 클래스에서 오버라이드하는 메소드의 접근 제어자는 부모 클래스보다 더 좁게 설정할 수 없다.
      - 예외(Exception)는 부모 클래스의 메소드보다 많이 선언할 수 없다.
      - static 메소드를 인스턴스의 메소드로 또는 그 반대로 바꿀 수 없다.
        - 부모 클래스의 static메소드를 자식에서 같은 이름으로 정의는 할 수 있지만
          이것은 다시 정의 하는 것이 아니라 같은 이름의 static메소드를 새로 정의 하는것이다.

3. 상속(inheritance)
   - 자식 클래스는 부모클래스를 선택해서 _"그 부모의 멤버를 상속받아 그대로 쓸 수 있다."_
   - 이미 마련되어 있던 클래스를 재사용해서 만들 수 있기 때문에 효율적이며, 개발시간이 단축된다.
   - 부모 클래스의 private접근 제한을 갖는 필드 및 메소드는 자식이 물려받지 못한다.
   - 부모와 자식 클래스가 _서로 다른 패키지에 있다면_ default접근 제한이라도 자식을 물려받지 못한다.

4. super 키워드
   - 'super' 키워드는 부모 클래스(객체)를 나타냄.
   1. super() : 부모 클래스의 생성자를 호출하는 키워드 / 기본 생성자라면 () 내부에 아무런 값이 없고,
      매개변수 생성자라면 () 내에 매개변수들이 포함됨.
      ex) super(animalName, animalAge);
      - 주의 : 자식 클래스에서는 반드시 생성자 내부 첫줄에 선언.

   2. super.메서드명() : 부모 클래스의 메서드를 호출하는 키워드
      ex) super.move();

